<div class="section" id="id1">
<h1>安装</h1>
<ol class="arabic simple">
<li>下载并安装64-bit Julia (command line version), 可选择自定义的安装路径.</li>
<li>新建环境变量 <tt class="docutils literal">JULIA_HOME</tt>, 并指向 <tt class="docutils literal">Julia</tt> 的 <tt class="docutils literal">\bin</tt> 目录.</li>
<li>在 <tt class="docutils literal">PATH</tt> 环境变量下添加 <tt class="docutils literal">%JULIA_HOME%</tt>.</li>
</ol>
<!-- TEASER_END -->
</div>
<div class="section" id="repl">
<h1>REPL 基础</h1>
<p>系统命令</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<tbody valign="top">
<tr><td>ans</td>
<td>上一次计算结果</td>
</tr>
<tr><td>?</td>
<td>help mode, 等同于 help(xxx)</td>
</tr>
<tr><td>apropos(&quot;quit&quot;)</td>
<td>搜索和quit相关的命令</td>
</tr>
<tr><td>methods(filter)</td>
<td>查看filter函数详细信息</td>
</tr>
<tr><td>;</td>
<td>shell mode</td>
</tr>
<tr><td>whos()</td>
<td>查看全局变量信息</td>
</tr>
<tr><td>&#64;which sin(3)</td>
<td>查看sin(3)命令中调用了哪些method</td>
</tr>
<tr><td>edit(&quot;filename&quot;)</td>
<td>编辑文档</td>
</tr>
<tr><td>less(&quot;filename&quot;)</td>
<td>显示文档</td>
</tr>
<tr><td>clipboard(&quot;stuff&quot;)</td>
<td>将&quot;stuff&quot;拷贝到系统剪贴板</td>
</tr>
<tr><td>clipboard()</td>
<td>将剪贴板当前内容拷至当前REPL</td>
</tr>
<tr><td>dump()</td>
<td>显示一个Julia object相关信息</td>
</tr>
<tr><td>names()</td>
<td>显示某个module的所有exported names</td>
</tr>
<tr><td>workspace()</td>
<td>替换top-level module(Main), 并清除workspace</td>
</tr>
</tbody>
</table>
<p>按键</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<tbody valign="top">
<tr><td>Up/Down</td>
<td>显示之前输入的命令</td>
</tr>
<tr><td>Ctrl-R/Ctrl-S</td>
<td>搜索之前输出的内容</td>
</tr>
</tbody>
</table>
<p>语法</p>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<tbody valign="top">
<tr><td><tt class="docutils literal">+(2,3,4)</tt></td>
<td>等同于 <tt class="docutils literal">2+3+4</tt></td>
</tr>
<tr><td><tt class="docutils literal">pi</tt>, <tt class="docutils literal">golden</tt>, <tt class="docutils literal">e</tt></td>
<td>系统预定义常量</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">666//999</span></tt></td>
<td><tt class="docutils literal">//</tt> 用于rational number</td>
</tr>
<tr><td><tt class="docutils literal">y\x</tt></td>
<td><tt class="docutils literal">\</tt> 为reverse division, <tt class="docutils literal">x/y=y\x</tt></td>
</tr>
<tr><td><tt class="docutils literal">+=</tt>, <tt class="docutils literal"><span class="pre">-=</span></tt>, ...</td>
<td>这些符号也是允许的</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">[2,4].*[10,20]</span></tt></td>
<td>element-wise operation</td>
</tr>
<tr><td><tt class="docutils literal">a,b=5,3</tt></td>
<td>assign multiple variables, 返回类型: tuple</td>
</tr>
<tr><td><tt class="docutils literal">\sqrt&lt;TAB&gt;</tt></td>
<td>转换成LaTeX字符</td>
</tr>
</tbody>
</table>
<p>数制</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<tbody valign="top">
<tr><td>bits(20.0)</td>
<td>shows the literal binary representation of a number</td>
</tr>
<tr><td>hex(), oct()</td>
<td>to hex or oct</td>
</tr>
<tr><td>base(16, 266)</td>
<td>to a string in given base</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="arrays-and-tuples">
<h1>Arrays and Tuples</h1>
<p>Julia arrays are &quot;column-major&quot; (列主序). This means that you read down the columns:</p>
<pre class="code shell"><a name="rest_code_f183f19f644846d5a310e7dea80964eb-1"></a><span class="m">1</span> 3
<a name="rest_code_f183f19f644846d5a310e7dea80964eb-2"></a><span class="m">2</span> 4
</pre><ul class="simple">
<li>Column-major order: Fortran, R, Matlab, GNU Octave, BLAS, LAPACK, OpenGL/OpenGL ES, Julia</li>
<li>ROW-major order: C/C++, Mathematica, Pascal, Python, C#/CLI/.Net, Direct3D</li>
</ul>
<div class="section" id="simple-arrays">
<h2>Simple arrays</h2>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr><td>s=[1, 2.0, 3]</td>
<td>创建一个array, 类型为Float64</td>
</tr>
<tr><td>trifuns=[sin, cos, tan]</td>
<td>一个函数array</td>
</tr>
<tr><td>array=Array(Int64,5,2)</td>
<td>创建一个array, 并指定类型与大小, 等同于Array{Int64}(5,2)</td>
</tr>
<tr><td>[1, &quot;2&quot;, sin, 3.0]</td>
<td>同一个array可以包含不同类型</td>
</tr>
<tr><td>typeof(ans)</td>
<td>查看数据类型</td>
</tr>
<tr><td>Int64[1,2,3,4,5]</td>
<td>创建一个某种类型的array</td>
</tr>
<tr><td>Int64[]</td>
<td>创建一个空的Int64型array, 其它类型还包括String, Float64等</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="row-vectors">
<h2>Row vectors</h2>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr><td>[1 2 3 4]</td>
<td>1x4 Int64 array (row vector)</td>
</tr>
<tr><td>[1 2 3; 5 6 7]</td>
<td>2x3 Int64 matrix</td>
</tr>
</tbody>
</table>
<p>在julia中, column vector是一维矩阵, 而row vector是二维矩阵, 大概julia也是偏好列向量的计算系统. 比如:</p>
<pre class="code shell"><a name="rest_code_496ee517e52148be91fe3fbfc641018b-1"></a>julia&gt; <span class="o">[</span>1,2,3<span class="o">]</span>
<a name="rest_code_496ee517e52148be91fe3fbfc641018b-2"></a>3-element Array<span class="o">{</span>Int64,1<span class="o">}</span>:
<a name="rest_code_496ee517e52148be91fe3fbfc641018b-3"></a> 1
<a name="rest_code_496ee517e52148be91fe3fbfc641018b-4"></a> 2
<a name="rest_code_496ee517e52148be91fe3fbfc641018b-5"></a> 3
<a name="rest_code_496ee517e52148be91fe3fbfc641018b-6"></a>
<a name="rest_code_496ee517e52148be91fe3fbfc641018b-7"></a>julia&gt; <span class="o">[</span><span class="m">1</span> <span class="m">2</span> 3<span class="o">]</span>
<a name="rest_code_496ee517e52148be91fe3fbfc641018b-8"></a>1x3 Array<span class="o">{</span>Int64,2<span class="o">}</span>:
<a name="rest_code_496ee517e52148be91fe3fbfc641018b-9"></a> <span class="m">1</span>  <span class="m">2</span>  3
</pre><p>可以看出, 列向量是Array{Int64,1}类型而行向量是Array{Int64,2}</p>
</div>
<div class="section" id="range-objects">
<h2>Range objects</h2>
<p><tt class="docutils literal">1:10</tt> 等同于 <tt class="docutils literal">range(1,10)</tt>, 用途:</p>
<ol class="arabic simple">
<li>生成列向量. 比如 <tt class="docutils literal">[1:10]</tt>, 或 <tt class="docutils literal">collect(1:10)</tt></li>
<li>loop表达式: <tt class="docutils literal">for n in 1:10 print(n) end</tt></li>
</ol>
<p><tt class="docutils literal">[0:10:100]</tt> 从0到100(包括100), 步长10. 亦可用于浮点类型.</p>
<p><tt class="docutils literal">linspace(1,100,12)</tt> 从1到100, 12步, 即会产生12个数. 另一个类似函数是 <tt class="docutils literal">logspace()</tt>, 即它的 logarithmic 版本.</p>
</div>
<div class="section" id="matrix">
<h2>Matrix</h2>
<div class="section" id="id2">
<h3>创建</h3>
<p>创建一个2x3矩阵, 可使用:</p>
<ol class="arabic simple">
<li><tt class="docutils literal">[1 2 3; 4 5 6]</tt> (按行创建),</li>
<li>按列创建: <tt class="docutils literal">[[1, 2, 3] [4,5,6]]</tt></li>
<li><tt class="docutils literal">Array(Int64, 3,2)</tt> 创建一个二维矩阵</li>
<li><tt class="docutils literal"><span class="pre">reshape([1,2,3,4,5,6],</span> 2, 3)</tt>, 即将一个简单数组或矩阵变为想要形状.</li>
</ol>
<p><tt class="docutils literal">b=similar(a)</tt>        拷贝矩阵a给b(只拷形式作初始化用, 不拷数据)</p>
</div>
<div class="section" id="id3">
<h3>初始化</h3>
<ol class="arabic simple">
<li><tt class="docutils literal">collect(0:10:100)</tt> 创建列向量并赋值</li>
<li>使用 zeros, ones, trues, flases, fill, fill!, rand, randn, eye, diagm 等函数.</li>
<li>创建简单的向量后使用 reshape 转换成多维矩阵.</li>
<li>Comprehensions, 如 <tt class="docutils literal">[r*c for r in 1:5, c in 1:5]</tt></li>
</ol>
</div>
<div class="section" id="indexing">
<h3>元素indexing</h3>
<ol class="arabic simple">
<li>元素索引格式为 a[5], a[2,3] 这样的形式, 或者 getindex(a, 1, 3)</li>
<li>行索引: a[1, :] (单行), 或者 a[1:2, :] (多行)</li>
<li>列索引: a[:,2] (单列), a[:, 1:2] (多列), a[:] 会将整个矩阵返回成一个列向量.</li>
<li>对于二维数列(矩阵)a, indexing的时候可以有第三个分量, 试了以后貌似只能是1, 其它值都会出错. 即 a[:,2:6,1] 相当于 a[:,2:6]. 以后尽量不要用这种方式.</li>
</ol>
</div>
</div>
</div>
<div class="section" id="tips">
<h1>Tips</h1>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<tbody valign="top">
<tr><td>操作</td>
<td>说明</td>
</tr>
<tr><td>convert(Float64, i)</td>
<td>将 i 转换为Float64类型.</td>
</tr>
<tr><td>function parse(type, num, base=10)</td>
<td>default arguments</td>
</tr>
<tr><td>include(&quot;filename.jl&quot;)</td>
<td>包含另一个文件</td>
</tr>
<tr><td>repeat([4,2], outer=[3,1])</td>
<td>得到一个6x1的2D array, 即[4,2,4,2,4,2]</td>
</tr>
<tr><td>readdlm(&quot;matrixdata.txt&quot;)</td>
<td>读取一个数据文件并保存为矩阵, 一般文件名都用ASCIIString类型</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="other-tips">
<h1>Other Tips</h1>
<ul class="simple">
<li>Julia在windows下升级到最新版本只能通过下载新的exe文件安装, 覆盖安装之后再用 <tt class="docutils literal">Pkg.update()</tt> 更新包. 另外 cmder 替换windows本身的cmd已经足够好用, 试了下并不喜欢Julia官网推荐的基于Atom的集成环境Juno IDE.</li>
<li><tt class="docutils literal">for i in 1:k</tt> 如果 <tt class="docutils literal">k</tt> 小于1, 循环将不会被执行.</li>
<li><tt class="docutils literal">atan2(y,x)</tt> 结果会落在 (-pi, pi] 内, 而且Julia定义了 <tt class="docutils literal">atan2(0,0)</tt> 等于 <tt class="docutils literal">0</tt>. 注意范围内不包括 <tt class="docutils literal"><span class="pre">-pi</span></tt>, 可以验证 <tt class="docutils literal"><span class="pre">atan2(0,-1)</span></tt> 结果为 <tt class="docutils literal">pi</tt>.</li>
<li><tt class="docutils literal">2pi</tt> 表示 <tt class="docutils literal">6.283185307179586</tt>, 类似地, 一些常量和数字可以缩写在一起.</li>
<li>可以使用 <tt class="docutils literal">length()</tt> 获取一维array的大小, 对于二维数组, 会得到总元素个数. 想要得到多维数组的dimension信息, 需要使用 <tt class="docutils literal">size()</tt></li>
<li><tt class="docutils literal">isfile(path)</tt> 检测文件是否存在. <tt class="docutils literal">rm(path)</tt> 可用于删除文件</li>
<li><tt class="docutils literal">&#64;show()</tt> 可以接受多个参数, 用于debug时打印出中间变量到console, 非常方便.</li>
<li><tt class="docutils literal">&#64;time</tt> macro加在执行命令的前面用于测试运行时间. 第一次调用时运行时间会稍长, 之后的调用会比较短. 因此以之后的为准.</li>
<li><tt class="docutils literal">0^0</tt> 在 Julia 中被定义为1, 在Mathematica中会报错(只能说MMA比较2, 经常涉及到Bernstein的定义都要用个Switch来考虑一下特殊情况).</li>
</ul>
</div>
